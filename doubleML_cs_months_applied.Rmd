---
title: "Custom_Replication"
output: html_document
date: "2026-01-14"
---

```{r}
library(dplyr)
library(ranger)
library(glmnet)
library(NuisanceParameters)
library(haven)

CashBail <- read_stata("CashBail.dta") 

#------------------------------------------------------------------------------
#                   Double ML Cross-Sectional DiD 
#-----------------------------------------------------------------------------


doubleML_did_cs_gate <- function(data, y_var, d_var, t_var, x_vars, methods, cf = 5,
                                 feature_eng = FALSE, bin_cut = 0.02, corr_cut = 0.9,
                                 cluster_var = NULL,
                                 heterogeneity = FALSE, gate_var = NULL) {
  
  Y  <- data[[y_var]]
  D  <- as.numeric(data[[d_var]])
  Tt <- as.numeric(data[[t_var]])
  X_0 <- as.matrix(data[, x_vars])
  n  <- length(Y)
  
  if (!is.null(cluster_var)) {
    C <- data[[cluster_var]]
  }
  
  if (feature_eng) {
    X_expanded <- design_matrix(X_0, int = "all", int_d = 2,
                                poly = "all", poly_d = 2)
    X <- data_screen(X_expanded, treat = D,
                     bin_cut = bin_cut, corr_cut = corr_cut,
                     quiet = TRUE)
  } else {
    X <- X_0
  }
  
  # Kombiniertes Treatment: (D,T)
  DT_combined <- 2 * D + Tt
  
  # ---- 1) m(X)
  np_m <- nuisance_parameters(
    NuPa = "D.hat", X = X, D = D,
    methods = methods, cf = cf,
    stacking = "short", stratify = TRUE, ensemble_type = "nnls",
    quiet = TRUE
  )
  m_hat <- as.numeric(np_m$nuisance_parameters$D.hat)
  
  # ---- 2) g(d,t,X)
  np_g <- nuisance_parameters(
    NuPa = "Y.hat.d",
    X = X,
    Y = Y,
    D = DT_combined,
    methods = methods,
    cf = cf,
    stacking = "short",
    stratify = TRUE,
    ensemble_type = "nnls",
    quiet = TRUE
  )
  
  g00_hat <- np_g$nuisance_parameters$Y.hat.d[, 1]  # D=0,T=0
  g01_hat <- np_g$nuisance_parameters$Y.hat.d[, 2]  # D=0,T=1
  g10_hat <- np_g$nuisance_parameters$Y.hat.d[, 3]  # D=1,T=0
  g11_hat <- np_g$nuisance_parameters$Y.hat.d[, 4]  # D=1,T=1
  
  # ---- 3) Score (ATT)
  psi_a <- -D / mean(D)
  
  psi_b <- D / mean(D) * (g11_hat - g10_hat - (g01_hat - g00_hat)) +
    (Tt * D / mean(D * Tt)) * (Y - g11_hat) -
    (D * (1 - Tt) / mean(D * (1 - Tt))) * (Y - g10_hat) -
    (m_hat * (1 - D) * Tt / (1 - m_hat)) /
    mean(m_hat * (1 - D) * Tt / (1 - m_hat)) * (Y - g01_hat) +
    (m_hat * (1 - D) * (1 - Tt) / (1 - m_hat)) /
    mean(m_hat * (1 - D) * (1 - Tt) / (1 - m_hat)) * (Y - g00_hat)
  
  theta_hat <- -mean(psi_b) / mean(psi_a)
  
  psi <- psi_a * theta_hat + psi_b
  influence_fun <- -1 / mean(psi_a) * psi
  
  if (is.null(cluster_var)) {
    se_hat <- sqrt(mean(psi^2) / (mean(psi_a)^2 * n))
    clustered <- FALSE
  } else {
    clusters <- unique(C)
    cluster_sums_squared <- rep(NA_real_, length(clusters))
    index <- 1
    for (cl in clusters) {
      cluster_sums_squared[index] <- sum(influence_fun[C == cl])^2
      index <- index + 1
    }
    var_hat <- 1 / n * sum(cluster_sums_squared)
    se_hat <- sqrt(var_hat / n)
    clustered <- TRUE
  }
  
  # ---- 4) Return object (base)
  out <- list(
    coefficients = c(ATT = theta_hat),
    se = se_hat,
    clustered = clustered,
    t = theta_hat / se_hat,
    p = 2 * (1 - pnorm(abs(theta_hat / se_hat))),
    ci_lower = theta_hat - 1.96 * se_hat,
    ci_upper = theta_hat + 1.96 * se_hat,
    N = n,
    N_treated = sum(D),
    N_control = sum(1 - D),
    N_post = sum(Tt),
    N_pre = sum(1 - Tt),
    y_var = y_var,
    d_var = d_var,
    t_var = t_var,
    x_vars = x_vars,
    n_covariates = ncol(X),
    cf = cf,
    methods = names(methods),
    feature_eng = feature_eng,
    cluster_var = cluster_var
  )
  
  # ------ 5) GATE  -------
  
  if (heterogeneity) {
    
    if (is.null(gate_var)) stop("heterogeneity = TRUE requires gate_var")
    
    G <- as.factor(data[[gate_var]])
    groups <- levels(G)
    
    # containers
    tau_hat <- rep(NA_real_, length(groups))
    names(tau_hat) <- groups
    
    IF_mat <- matrix(NA_real_, nrow = n, ncol = length(groups))
    colnames(IF_mat) <- groups
    
    for (j in seq_along(groups)) {
      g <- groups[j]
      I_g <- as.numeric(G == g)
      
      denom <- mean(I_g * psi_a)
      if (abs(denom) < 1e-12) {
        stop(paste0("Group ", g, " has near-zero denom E[I_g*psi_a]."))
      }
      
      num <- mean(I_g * psi_b)
      tau_hat[g] <- - num / denom
      
      # Influence function for tau_g
      psi_g <- I_g * (psi_a * tau_hat[g] + psi_b)
      IF_mat[, j] <- -1 / denom * psi_g
    }
    
    # SEs using the same logic as ATT, applied per group
    gate_se <- rep(NA_real_, length(groups))
    names(gate_se) <- groups
    
    if (is.null(cluster_var)) {
      for (j in seq_along(groups)) {
        gate_se[j] <- sqrt(mean(IF_mat[, j]^2) / n)
      }
      gate_clustered <- FALSE
    } else {
      clusters <- unique(C)
      for (j in seq_along(groups)) {
        infl <- IF_mat[, j]
        cluster_sums_squared <- rep(NA_real_, length(clusters))
        k <- 1
        for (cl in clusters) {
          cluster_sums_squared[k] <- sum(infl[C == cl])^2
          k <- k + 1
        }
        var_hat_g <- 1 / n * sum(cluster_sums_squared)
        gate_se[j] <- sqrt(var_hat_g / n)
      }
      gate_clustered <- TRUE
    }
    
    gate_t <- tau_hat / gate_se
    gate_p <- 2 * (1 - pnorm(abs(gate_t)))
    
    out$gate <- list(
      tau = tau_hat,
      se = gate_se,
      clustered = gate_clustered,
      t = gate_t,
      p = gate_p,
      ci_lower = tau_hat - 1.96 * gate_se,
      ci_upper = tau_hat + 1.96 * gate_se,
      groups = groups,
      N = n,
      gate_var = gate_var,
      influence_function = IF_mat
    )
  }
  class(out) <- "doubleML_did_cs_gate"
  return(out)
}





#-----------------------------------------------------------
#   summary + print methods for DID-CS with optional GATE
#   class: "doubleML_did_cs_gate"
#-----------------------------------------------------------

summary.doubleML_did_cs_gate <- function(object, digits = 4, ...) {
  
  # --- ATT table
  att_tab <- data.frame(
    Estimate       = round(object$coefficients["ATT"], digits),
    `Std. Error`   = round(object$se, digits),
    `t value`      = round(object$t, digits),
    `Pr(>|t|)`     = format.pval(object$p, digits = digits),
    `95% CI Lower` = round(object$ci_lower, digits),
    `95% CI Upper` = round(object$ci_upper, digits),
    check.names = FALSE
  )
  rownames(att_tab) <- "ATT"
  
  cat("\n===============================================\n")
  cat("  DoubleML DID Callaway-Sant'Anna Estimation\n")
  cat("===============================================\n")
  
  cat("\nSample Information:\n")
  cat(sprintf("  Total N: %d\n", object$N))
  cat(sprintf("  Treated: %d (%.1f%%)\n", object$N_treated, 
              100 * object$N_treated / object$N))
  cat(sprintf("  Control: %d (%.1f%%)\n", object$N_control, 
              100 * object$N_control / object$N))
  cat(sprintf("  Post-period: %d (%.1f%%)\n", object$N_post, 
              100 * object$N_post / object$N))
  
  cat("\nModel Specification:\n")
  cat(sprintf("  Outcome: %s\n", object$y_var))
  cat(sprintf("  Treatment: %s\n", object$d_var))
  cat(sprintf("  Time: %s\n", object$t_var))
  cat(sprintf("  Covariates: %d\n", object$n_covariates))
  cat(sprintf("  Cross-fitting folds: %d\n", object$cf))
  cat(sprintf("  ML methods: %s\n", paste(object$methods, collapse = ", ")))
  if (!is.null(object$cluster_var)) {
    cat(sprintf("  Clustered SEs: %s\n", object$cluster_var))
  }
  
  cat("\n--- Average Treatment Effect on the Treated (ATT) ---\n")
  print(att_tab, quote = FALSE)
  
  # --- Optional GATE table
  if (!is.null(object$gate) && is.list(object$gate)) {
    
    gate <- object$gate
    groups <- gate$groups
    if (is.null(groups)) groups <- names(gate$tau)
    
    gate_tab <- data.frame(
      Group          = groups,
      Estimate       = round(as.numeric(gate$tau[groups]), digits),
      `Std. Error`   = round(as.numeric(gate$se[groups]), digits),
      `t value`      = round(as.numeric(gate$t[groups]), digits),
      `Pr(>|t|)`     = format.pval(as.numeric(gate$p[groups]), digits = digits),
      `95% CI Lower` = round(as.numeric(gate$ci_lower[groups]), digits),
      `95% CI Upper` = round(as.numeric(gate$ci_upper[groups]), digits),
      check.names = FALSE
    )
    
    cat("\n--- Group Average Treatment Effects (GATE) ---\n")
    cat(sprintf("Grouping variable: %s\n\n", gate$gate_var))
    print(gate_tab, quote = FALSE, row.names = FALSE)
    
    # Add significance stars
    cat("\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n")
  }
  
  cat("\n===============================================\n")
  invisible(object)
}

print.doubleML_did_cs_gate <- function(x, digits = 4, ...) {
  cat("\n===============================================\n")
  cat("  DoubleML DID-CS Estimate\n")
  cat("===============================================\n")
  
  cat("\nOutcome:", x$y_var, "\n")
  cat("Sample: N =", x$N, 
      sprintf("(Treated = %d, Control = %d)\n", x$N_treated, x$N_control))
  
  cat("\nAverage Treatment Effect on the Treated (ATT):\n")
  cat(sprintf("  Estimate: %.*f\n", digits, x$coefficients["ATT"]))
  cat(sprintf("  Std. Error: %.*f\n", digits, x$se))
  cat(sprintf("  t-value: %.*f\n", digits, x$t))
  cat(sprintf("  p-value: %s\n", format.pval(x$p, digits = digits)))
  cat(sprintf("  95%% CI: [%.*f, %.*f]\n", 
              digits, x$ci_lower, digits, x$ci_upper))
  
  # Add significance indicator
  sig <- ifelse(x$p < 0.001, "***",
                ifelse(x$p < 0.01, "**",
                       ifelse(x$p < 0.05, "*",
                              ifelse(x$p < 0.1, ".", ""))))
  if (sig != "") {
    cat(sprintf("  Significance: %s\n", sig))
  }
  
  if (!is.null(x$gate) && is.list(x$gate)) {
    cat("\n--- Group Average Treatment Effects (GATE) ---\n")
    cat(sprintf("Grouping variable: %s\n\n", x$gate$gate_var))
    
    gate <- x$gate
    groups <- gate$groups
    if (is.null(groups)) groups <- names(gate$tau)
    
    for (g in groups) {
      est <- as.numeric(gate$tau[g])
      se <- as.numeric(gate$se[g])
      p <- as.numeric(gate$p[g])
      
      sig_g <- ifelse(p < 0.001, "***",
                      ifelse(p < 0.01, "**",
                             ifelse(p < 0.05, "*",
                                    ifelse(p < 0.1, ".", ""))))
      
      cat(sprintf("  %s: %.*f (SE: %.*f) %s\n", 
                  g, digits, est, digits, se, sig_g))
    }
  }
  
  cat("\n===============================================\n")
  invisible(x)
}
```


## Data Preparation
```{r}
CashBail <- CashBail %>%
  mutate(
    yq_numeric = as.numeric(as.factor(yq)),
    # Creating past_fel from prior_fel 
    past_fel = as.numeric(prior_fel > 0),
    
    # Creating Denied 
    Denied = as.numeric(initialbailtype == "Denied"),
    
    # Addressing NAs
    income_missing = as.numeric(is.na(defendantzipmedianhouseholdincom)),
    poverty_missing = as.numeric(is.na(PctBelPov)),
    
    defendantzipmedianhouseholdincom = ifelse(is.na(defendantzipmedianhouseholdincom), 
                                              mean(defendantzipmedianhouseholdincom, na.rm = TRUE), 
                                              defendantzipmedianhouseholdincom),
    
    PctBelPov = ifelse(is.na(PctBelPov), 
                       mean(PctBelPov, na.rm = TRUE), 
                       PctBelPov),
    
    PostElig = EligibleOffense * Post,
  
    off = as.factor(off),
    yq = as.factor(yq),
    DOW = as.factor(DOW), 
    CommissionerName_input = as.factor(CommissionerName_input) 
  )
```

### Defining Inputs

```{r}
outcomes_table3 <- c("ROR", "Jail3days")
outcomes_table5 <- c("hasfta", "Rec6mo")
all_outcomes <- c(outcomes_table3, outcomes_table5)

covariates <- c("defendantageatarrest", "male", "defendantisblack", "Hisp", 
                "White", "defendantzipmedianhouseholdincom", "PctBelPov", 
                "PD", "felony", "prior_FTA", "prior_9y", "past_fel", "income_missing", "poverty_missing")

# ML Methods 
my_methods <- list(
  D.hat = list(
   m1 = list(method = "ranger")#, tuning="fold")
  ),
  Y.hat.d = list(
    m1 = list(method = "ranger")#,tuning="fold")
  )
)
```

```{r}
dml_results <- list()

set.seed(1234) 

# Run ATT estimation for each outcome (heterogeneity = FALSE)
for(y in all_outcomes) {
  message("Running ATT estimation for outcome: ", y)
  
  dml_results[[y]] <- doubleML_did_cs_gate(
    data = CashBail,
    y_var = y,
    d_var = "EligibleOffense",
    t_var = "Post",
    x_vars = covariates,
    methods = my_methods,
    cf = 5,              
    cluster_var = "off",
    heterogeneity = FALSE
  )
}
```

## ATT Results Summary
```{r}
# Extract ATT results for all outcomes
final_dml_table <- do.call(rbind, lapply(all_outcomes, function(y) {
  res <- dml_results[[y]]
  data.frame(
    Outcome = y,
    ATT = res$coefficients["ATT"],
    Std_Error = res$se,
    t_stat = res$t,
    p_val = res$p,
    Lower_CI = res$ci_lower,
    Upper_CI = res$ci_upper
  )
}))

print(final_dml_table)
```

## Detailed ATT Results

```{r}
# Display detailed ATT results for each outcome
for(y in all_outcomes) {
  cat("\n\n========================================\n")
  cat("OUTCOME:", y, "\n")
  cat("========================================\n")
  summary(dml_results[[y]])
}
```

## Event Study Double ML DiD

### Create Month Variable Relative to Reform

```{r}
# Reform date: February 22, 2018
# In Stata dates, this is the number of days since January 1, 1960
reform_date <- as.Date("2018-02-22")

# Create relative month variable based on Stata code logic
CashBail <- CashBail %>%
  mutate(
    # Convert baildate to R date (Stata dates are days since Jan 1, 1960)
    baildate_r = as.Date(baildate, origin = "1960-01-01"),
    # Days relative to reform
    days_relative = as.numeric(baildate_r - reform_date),
    # Create month bins following Stata logic
    # pre1 (becomes pre0): -30 to -1 days (reference month -1)
    # pre2 (becomes pre1): -60 to -31 days (month -2)
    # etc.
    rel_month = case_when(
      days_relative >= -30 & days_relative < 0 ~ -1,    # Reference period (Month -1)
      days_relative >= -60 & days_relative < -30 ~ -2,  # Month -2
      days_relative >= -90 & days_relative < -60 ~ -3,  # Month -3
      days_relative >= -120 & days_relative < -90 ~ -4, # Month -4
      days_relative >= -150 & days_relative < -120 ~ -5,# Month -5
      days_relative >= -180 & days_relative < -150 ~ -6,# Month -6
      days_relative > 0 & days_relative <= 30 ~ 0,      # Month 0 (first month post)
      days_relative > 30 & days_relative <= 60 ~ 1,     # Month 1
      days_relative > 60 & days_relative <= 90 ~ 2,     # Month 2
      days_relative > 90 & days_relative <= 120 ~ 3,    # Month 3
      days_relative > 120 & days_relative <= 150 ~ 4,   # Month 4
      TRUE ~ NA_real_
    )
  )

# Check distribution
table(CashBail$rel_month, useNA = "ifany")
```

### Event Study Function

```{r}
#------------------------------------------------------------------------------
#                   Double ML Event Study DiD 
#------------------------------------------------------------------------------

doubleML_event_study <- function(data, y_var, d_var, month_var, x_vars, methods, 
                                  cf = 5, cluster_var = NULL,
                                  base_month = -1, 
                                  pre_months = c(-6, -5, -4, -3, -2),
                                  post_months = c(0, 1, 2, 3, 4)) {
  
  # All months to estimate (excluding base month)
  all_months <- c(pre_months, post_months)
  
  # Initialize results storage
  results <- data.frame(
    month = numeric(),
    estimate = numeric(),
    se = numeric(),
    ci_lower = numeric(),
    ci_upper = numeric(),
    n_total = numeric(),
    n_month_k = numeric(),
    n_base = numeric()
  )
  
  # Get base month data
  base_data <- data %>% filter(!!sym(month_var) == base_month)
  n_base <- nrow(base_data)
  
  message(sprintf("Base month %d: N = %d", base_month, n_base))
  
  # Loop through each month k
  for (k in all_months) {
    
    message(sprintf("\n--- Estimating Month %d vs Base Month %d ---", k, base_month))
    
    # Filter to only month k and base month
    slice_data <- data %>%
      filter(!!sym(month_var) %in% c(k, base_month)) %>%
      mutate(
        # T = 1 if month k, T = 0 if base month
        T_event = as.numeric(!!sym(month_var) == k)
      )
    
    n_month_k <- sum(slice_data$T_event == 1)
    n_slice <- nrow(slice_data)
    
    message(sprintf("  Month %d: N = %d, Base: N = %d, Total slice: N = %d", 
                    k, n_month_k, n_slice - n_month_k, n_slice))
    
    # Check if we have enough observations
    if (n_month_k < 50 || (n_slice - n_month_k) < 50) {
      warning(sprintf("Month %d has insufficient observations. Skipping.", k))
      results <- rbind(results, data.frame(
        month = k,
        estimate = NA,
        se = NA,
        ci_lower = NA,
        ci_upper = NA,
        n_total = n_slice,
        n_month_k = n_month_k,
        n_base = n_slice - n_month_k
      ))
      next
    }
    
    # Run Double ML DiD on this slice
    tryCatch({
      dml_result <- doubleML_did_cs_gate(
        data = slice_data,
        y_var = y_var,
        d_var = d_var,
        t_var = "T_event",  # Our constructed time variable
        x_vars = x_vars,
        methods = methods,
        cf = cf,
        cluster_var = cluster_var,
        heterogeneity = FALSE
      )
      
      # Store results
      results <- rbind(results, data.frame(
        month = k,
        estimate = dml_result$coefficients["ATT"],
        se = dml_result$se,
        ci_lower = dml_result$ci_lower,
        ci_upper = dml_result$ci_upper,
        n_total = n_slice,
        n_month_k = n_month_k,
        n_base = n_slice - n_month_k
      ))
      
      message(sprintf("  ATT = %.4f (SE = %.4f)", 
                      dml_result$coefficients["ATT"], dml_result$se))
      
    }, error = function(e) {
      warning(sprintf("Error for month %d: %s", k, e$message))
      results <<- rbind(results, data.frame(
        month = k,
        estimate = NA,
        se = NA,
        ci_lower = NA,
        ci_upper = NA,
        n_total = n_slice,
        n_month_k = n_month_k,
        n_base = n_slice - n_month_k
      ))
    })
  }
  
  # Add the reference period (month -1) with estimate = 0
  results <- rbind(results, data.frame(
    month = base_month,
    estimate = 0,
    se = 0,
    ci_lower = 0,
    ci_upper = 0,
    n_total = n_base,
    n_month_k = n_base,
    n_base = n_base
  ))
  
  # Sort by month
  results <- results %>% arrange(month)
  rownames(results) <- NULL
  
  # Return results
  out <- list(
    results = results,
    y_var = y_var,
    d_var = d_var,
    base_month = base_month,
    pre_months = pre_months,
    post_months = post_months
  )
  
  class(out) <- "doubleML_event_study"
  return(out)
}


#------------------------------------------------------------------------------
#                   Plotting Function for Event Study
#------------------------------------------------------------------------------

plot_event_study <- function(es_result, title = NULL, 
                              ylim = c(-0.15, 0.2),
                              show_ci = TRUE) {
  
  library(ggplot2)
  
  df <- es_result$results
  
  if (is.null(title)) {
    title <- paste("Event Study:", es_result$y_var)
  }
  
  # Create the plot
  p <- ggplot(df, aes(x = month, y = estimate)) +
    geom_hline(yintercept = 0, linetype = "solid", color = "gray50") +
    geom_vline(xintercept = -0.5, linetype = "dashed", color = "gray50") +
    geom_point(size = 3) +
    geom_line() +
    labs(
      title = title,
      x = "Months Relative to Reform (Feb. 22, 2018)",
      y = "ATT Estimate"
    ) +
    scale_x_continuous(breaks = seq(-6, 4, by = 1)) +
    coord_cartesian(ylim = ylim) +
    theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      plot.title = element_text(hjust = 0.5, face = "bold")
    )
  
  if (show_ci) {
    p <- p + geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), 
                           width = 0.2, alpha = 0.7)
  }
  
  return(p)
}
```

### Run Event Study for All Outcomes

```{r, message=TRUE, warning=TRUE}
# Filter data to only include observations within the event study window
CashBail_es <- CashBail %>%
  filter(!is.na(rel_month))

message(sprintf("Event study sample: N = %d", nrow(CashBail_es)))

# Store event study results
event_study_results <- list()

set.seed(1234)

# Run event study for each outcome
for (y in all_outcomes) {
  message("\n\n========================================")
  message("EVENT STUDY FOR OUTCOME: ", y)
  message("========================================")
  
  event_study_results[[y]] <- doubleML_event_study(
    data = CashBail_es,
    y_var = y,
    d_var = "EligibleOffense",
    month_var = "rel_month",
    x_vars = covariates,
    methods = my_methods,
    cf = 5,
    cluster_var = "off",
    base_month = -1,
    pre_months = c(-6, -5, -4, -3, -2),
    post_months = c(0, 1, 2, 3, 4)
  )
}
```

### Event Study Results Tables

```{r}
# Print results for each outcome
for (y in all_outcomes) {
  cat("\n\n========================================\n")
  cat("EVENT STUDY RESULTS:", y, "\n")
  cat("========================================\n\n")
  
  res <- event_study_results[[y]]$results
  res$estimate <- round(res$estimate, 4)
  res$se <- round(res$se, 4)
  res$ci_lower <- round(res$ci_lower, 4)
  res$ci_upper <- round(res$ci_upper, 4)
  
  print(res)
}
```

### Event Study Plots

```{r, fig.width=10, fig.height=8}
library(ggplot2)
library(gridExtra)

# Create individual plots
plots <- list()

outcome_labels <- c(
  "ROR" = "Released on Own Recognizance",
  "Jail3days" = "Jail > 3 Days",
  "hasfta" = "Failure to Appear",
  "Rec6mo" = "Recidivism (6 months)"
)

for (y in all_outcomes) {
  plots[[y]] <- plot_event_study(
    event_study_results[[y]], 
    title = outcome_labels[y],
    ylim = c(-0.15, 0.2)
  )
}

# Combine plots
combined_plot <- grid.arrange(
  plots[["ROR"]], 
  plots[["Jail3days"]], 
  plots[["hasfta"]], 
  plots[["Rec6mo"]],
  ncol = 2,
  top = "Double ML Event Study DiD"
)

# Save the combined plot
ggsave("doubleML_cs_months_figure.png", combined_plot, width = 12, height = 10, dpi = 300)
```

### Summary Statistics by Month

```{r}
# Summary of sample sizes by month
cat("\n========================================\n")
cat("SAMPLE SIZES BY RELATIVE MONTH\n")
cat("========================================\n\n")

month_summary <- CashBail_es %>%
  group_by(rel_month) %>%
  summarise(
    N = n(),
    N_Eligible = sum(EligibleOffense),
    N_Ineligible = sum(1 - EligibleOffense),
    Pct_Eligible = round(100 * mean(EligibleOffense), 1)
  ) %>%
  arrange(rel_month)

print(month_summary)
```


